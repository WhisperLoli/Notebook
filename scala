注意：
  1. 区分大小写 -  Scala是大小写敏感的
  2. 类名 - 对于所有的类名的第一个字母要大写
  3. 方法名称 - 所有的方法名称的第一个字母用小写
  4. 程序文件名 - 程序文件的名称应该与对象名称完全匹配(新版本不需要了，但建议保留这种习惯)
  5. def main(args: Array[String]) - Scala程序从main()方法开始处理，这是每一个Scala程序的强制程序入口部分

标识符：
  Scala 可以使用两种形式的标志符，字符数字和符号
    字符数字使用字母或是下划线开头，后面可以接字母或是数字，符号"$"在 Scala 中也看作为字母。然而以"$"开头的标识符为保留的 Scala 编译器产生的标志符使用，应用程序应该避免使用"$"开始的标识符，以免造成冲突
    此外也应该避免使用以下划线结尾的标志符以避免冲突。符号标志符包含一个或多个符号，如+，:，? 等，比如：+ ++ ::: < ?> :->
    你可以在"之间使用任何有效的 Scala 标志符，Scala 将它们解释为一个 Scala 标志符，一个典型的使用为 Thread 的 yield 方法， 在 Scala 中你不能使用 Thread.yield()是因为 yield 为 Scala 中的关键字， 你必须使用 Thread.`yield`()来使用这个方法。
 
引用：
  import java.awt.Color  // 引入Color
  import java.awt._  // 引入包内所有成员
  / 重命名成员
  import java.util.{HashMap => JavaHashMap}
  // 隐藏成员
  import java.util.{HashMap => _, _} // 引入了util包的所有成员，但是HashMap被隐藏了
  
  默认情况下，Scala 总会引入 java.lang._ 、 scala._ 和 Predef._
  
数据类型：
  Byte	8位有符号补码整数。数值区间为 -128 到 127
  Short	16位有符号补码整数。数值区间为 -32768 到 32767
  Int	32位有符号补码整数。数值区间为 -2147483648 到 2147483647
  Long	64位有符号补码整数。数值区间为 -9223372036854775808 到 9223372036854775807
  Float	32位IEEE754单精度浮点数
  Double	64位IEEE754单精度浮点数
  Char	16位无符号Unicode字符, 区间值为 U+0000 到 U+FFFF
  String	字符序列
  Boolean	true或false
  Unit	表示无值，和其他语言中void等同。用作不返回任何结果的方法的结果类型。Unit只有一个实例值，写成()。
  Null	null 或空引用
  Nothing	Nothing类型在Scala的类层级的最低端；它是任何其他类型的子类型。
  Any	Any是所有其他类的超类
  AnyRef	AnyRef类是Scala里所有引用类(reference class)的基类
  
变量：
  一、变量： 在程序运行过程中其值可能发生改变的量叫做变量。如：时间，年龄。
  二、常量 在程序运行过程中其值不会发生变化的量叫做常量。如：数值 3，字符'A'
  
  在 Scala 中，使用关键词 "var" 声明变量，使用关键词 "val" 声明常量
  变量声明一定需要初始值，否则会报错
  val xmax, ymax = 100  // xmax和ymax都声明为100
  
访问修饰符：
  Scala 访问修饰符基本和Java的一样，分别有：private，protected，public。
  如果没有指定访问修饰符符，默认情况下，Scala 对象的访问级别都是 public。
  Scala 中的 private 限定符，比 Java 更严格，在嵌套类情况下，外层类甚至不能访问被嵌套类的私有成员。 
  在 scala 中，对保护（Protected）成员的访问比 java 更严格一些。因为它只允许保护成员在定义了该成员的的类的子类中被访问。
  
  Scala中，访问修饰符可以通过使用限定词强调。格式为:

  private[x] 或 protected[x]
  这里的x指代某个所属的包、类或单例对象。如果写成private[x],读作"这个成员除了对[…]中的类或[…]中的包中的类及它们的伴生对像可见外，对其它所有类都是private。

循环break:
  // 导入以下包
  import scala.util.control._
  // 创建 Breaks 对象
  val loop = new Breaks;
  // 在 breakable 中循环
  loop.breakable{
    // 循环
    for(...){
       ....
       // 循环中断
       loop.break;
    }
  }
  
方法与函数：
  Scala 中使用 val 语句可以定义函数，def 语句定义方法。
  方法定义：
     def functionName ([参数列表]) : [return type]
     如果你不写等于号和方法主体，那么方法会被隐式声明为抽象(abstract)，包含它的类型于是也是一个抽象类型。
  在进入函数内部前，传值调用方式就已经将参数表达式的值计算完毕，而传名调用是在函数内部进行参数表达式的值计算的。这就造成了一种现象，每次使用传名调用时，解释器都会计算一次表达式的值。
  Scala 通过在参数的类型之后放一个*来设置可变参数(可重复的参数)
  Scala 可以为函数参数指定默认参数值，使用了默认参数，你在调用函数的过程中可以不需要传递参数，这时函数就会调用它的默认参数值，如果传递了参数，则传递值会取代默认值。
  
  匿名函数：
    示例：var inc = (x:Int) => x+1
         var userDir = () => { System.getProperty("user.dir") }
  柯里化(Currying)指的是将原来接受两个参数的函数变成新的接受一个参数的函数的过程。新的函数返回一个以原有第二个参数为参数的函数。
  
  区别：
    函数可作为一个参数传入到方法中，而方法不行。如果直接传递的是方法名称，scala相当于是把方法转成了函数
    在Scala中无法直接操作方法，如果要操作方法，必须先将其转换成函数。
    有两种方法可以将方法转换成函数：
      val f1 = m _                      在方法名称m后面紧跟一个空格和下划线告诉编译器将方法m转换成函数，而不是要调用这个方法。 
      val f1: (Int) => Int = m
    函数必须要有参数列表，而方法可以没有参数列表
    在函数出现的地方我们可以提供一个方法
       如果我们直接把一个方法赋值给变量会报错。如果我们指定变量的类型就是函数，那么就可以通过编译

闭包：
  闭包是一个函数，返回值依赖于声明在函数外部的一个或多个变量。
  闭包通常来讲可以简单的认为是可以访问一个函数里面局部变量的另外一个函数。
  示例：
    var factor = 3  
    val multiplier = (i:Int) => i * factor  
    
数组：
  var z = new Array[String](3)
  使用：
      z(0) = "Runoob"; z(1) = "Baidu"; z(4/2) = "Google"
      var myList = Array(1.9, 2.9, 3.4, 3.5) 
      // 输出所有数组元素
      for ( x <- myList ) {
         println( x )
      }
      // 计算数组所有元素的总和
      var total = 0.0;
      for ( i <- 0 to (myList.length - 1)) {
         total += myList(i);
      }
   数组合并：
      var myList3 =  concat( myList1, myList2)
二维数组：
   var myMatrix = ofDim[Int](3,3)    //参数有几个，就是几维数组
   // 创建矩阵
    for (i <- 0 to 2) {
       for ( j <- 0 to 2) {
          myMatrix(i)(j) = j;
       }
    }
区间数组：
   range() 方法来生成一个区间范围内的数组。range() 方法最后一个参数为步长，默认为 1
集合：
   Scala 集合分为可变的和不可变的集合
   列表是不可变的，值一旦被定义了就不能改变，其次列表 具有递归的结构（也就是链接表结构）而数组不是。
   可变集合可以在适当的地方被更新或扩展。这意味着你可以修改，添加，移除一个集合的元素。
   而不可变集合类，相比之下，永远不会改变。不过，你仍然可以模拟添加，移除或更新操作。但是这些操作将在每一种情况下都返回一个新的集合，同时使原来的集合不发生改变。
   
   List是不可变的，值一旦被定义了就不能改变
   定义空列表：val empty: List[Nothing] = List()
   构造列表的两个基本单位是 Nil 和 ::
   Nil 也可以表示为一个空列表
   // 整型列表
   val nums = 1 :: (2 :: (3 :: (4 :: Nil)))
   // 空列表
   val empty = Nil
   你可以使用 ::: 运算符或 List.:::() 方法或 List.concat() 方法来连接两个或多个列表
   
   默认情况下，Scala 使用的是不可变集合
   虽然可变Set和不可变Set都有添加或删除元素的操作，但是有一个非常大的差别。对不可变Set进行操作，会产生一个新的set，原来的set并没有改变，这与List一样。 而对可变Set进行操作，改变的是该Set本身，与ListBuffer类似。
   你可以使用 ++ 运算符或 Set.++() 方法来连接两个集合。如果元素有重复的就会移除重复的元素
   使用 Set.& 方法或 Set.intersect 方法来查看两个集合的交集元素
   
   Map定义：
     val colors = Map("red" -> "#FF0000", "azure" -> "#F0FFFF")
     
   目前 Scala 支持的元组最大长度为 22。
   val t = (4,3,2,1)
   我们可以使用 t._1 访问第一个元素， t._2 访问第二个元素
   
Scala Option(选项)类型用来表示一个值是可选的（有值或无值)   
   Option[T] 是一个类型为 T 的可选值的容器： 如果值存在， Option[T] 就是一个 Some[T] ，如果不存在， Option[T] 就是对象 None 
   使用 getOrElse() 方法来获取元组中存在的元素或者使用其默认的值
   
类：
  Scala 的类定义可以有参数，称为类参数，类参数在整个类中都可以访问
  
  Scala继承一个基类跟Java很相似, 但我们需要注意以下几点：
    1、重写一个非抽象方法必须使用override修饰符。
    2、只有主构造函数才可以往基类的构造函数里写参数。
    3、在子类中重写超类的抽象方法时，你不需要使用override关键字
    
  Scala 中使用单例模式时，除了定义的类之外，还要定义一个同名的 object 对象，它和类的区别是，object对象不能带参数。

  当单例对象与某个类共享同一个名称时，他被称作是这个类的伴生对象：companion object。你必须在同一个源文件里定义类和它的伴生对象。
  类被称为是这个单例对象的伴生类：companion class。类和它的伴生对象可以互相访问其私有成员
  
Trait
  Scala Trait(特征) 相当于 Java 的接口，实际上它比接口还功能强大。
  与接口不同的是，它还可以定义属性和方法的实现。
  一般情况下Scala的类只能够继承单一父类，但是如果是 Trait(特征) 的话就可以继承多个，从结果来看就是实现了多重继承。
  子类继承特征可以实现未被实现的方法
 
case
  使用了case关键字的类定义就是就是样例类(case classes)，样例类是种特殊的类，经过优化以用于模式匹配。
  在声明样例类时，下面的过程自动发生了：
    构造器的每个参数都成为val，除非显式被声明为var，但是并不推荐这么做；
    在伴生对象中提供了apply方法，所以可以不使用new关键字就可构建对象；
    提供unapply方法使模式匹配可以工作；
    生成toString、equals、hashCode和copy方法，除非显示给出这些方法的定义。
